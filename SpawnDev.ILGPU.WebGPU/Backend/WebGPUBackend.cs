using global::ILGPU;
using global::ILGPU.Backends;
using global::ILGPU.Backends.EntryPoints;
using global::ILGPU.Runtime;
using System;
using System.Text;

namespace SpawnDev.ILGPU.WebGPU.Backend
{
    /// <summary>
    /// WebGPU/WGSL backend for ILGPU.
    /// Compiles ILGPU IR to WGSL shader code.
    /// </summary>
    public class WebGPUBackend : global::ILGPU.Backends.Backend
    {
        /// <summary>
        /// Creates a new WebGPU backend.
        /// </summary>
        /// <param name="context">The ILGPU context.</param>
        public WebGPUBackend(Context context)
            : base(context, new global::ILGPU.Runtime.WebGPU.WebGPUCapabilityContext(), 
                   BackendType.WebGPU, new WebGPUArgumentMapper(context)) 
        {
        }

        /// <summary>
        /// Compiles an ILGPU kernel entry point to WGSL.
        /// </summary>
        protected override CompiledKernel Compile(
            EntryPoint entryPoint, 
            in BackendContext backendContext, 
            in KernelSpecialization specialization)
        {
            var generator = new WGSLCodeGenerator(entryPoint);
            string wgslSource = generator.Generate();
            return new WebGPUCompiledKernel(Context, entryPoint, wgslSource);
        }
    }

    /// <summary>
    /// WGSL code generator that translates ILGPU kernel signatures to WGSL shader code.
    /// </summary>
    internal class WGSLCodeGenerator
    {
        private readonly EntryPoint _entryPoint;
        private readonly StringBuilder _source;
        private int _bindingIndex;

        /// <summary>
        /// Creates a new WGSL code generator.
        /// </summary>
        public WGSLCodeGenerator(EntryPoint entryPoint)
        {
            _entryPoint = entryPoint;
            _source = new StringBuilder();
            _bindingIndex = 0;
        }

        /// <summary>
        /// Generates WGSL compute shader source code.
        /// </summary>
        public string Generate()
        {
            // Generate header comment
            _source.AppendLine("// Generated by SpawnDev.ILGPU.WebGPU");
            _source.AppendLine($"// Kernel: {_entryPoint.Name}");
            _source.AppendLine();

            // Generate buffer bindings for parameters
            GenerateBufferBindings();

            // Generate the compute shader entry point
            GenerateComputeEntry();

            return _source.ToString();
        }

        private bool IsIndexType(Type type)
        {
            if (type == null) return false;
            return type == typeof(Index1D) || type == typeof(Index2D) || type == typeof(Index3D) ||
                   type == typeof(LongIndex1D) || type == typeof(LongIndex2D) || type == typeof(LongIndex3D);
        }

        private void GenerateBufferBindings()
        {
            var parameters = _entryPoint.Parameters;
            int binding = 0;
            
            for (int i = 0; i < parameters.Count; i++)
            {
                var paramType = parameters[i];
                
                // Skip index parameter (param 0 usually)
                if (i == 0 && IsIndexType(paramType)) continue;

                // Check if this is an ArrayView (buffer)
                if (IsArrayViewType(paramType))
                {
                    var elementType = GetArrayViewElementType(paramType);
                    var wgslType = MapToWGSLType(elementType);
                    
                    _source.AppendLine($"@group(0) @binding({binding}) var<storage, read_write> param{i} : array<{wgslType}>;");
                    binding++;
                }
                else
                {
                    // Uniform/scalar parameter - must be a struct in WebGPU
                    var wgslType = MapToWGSLType(paramType);
                    _source.AppendLine($"struct Param{i} {{");
                    _source.AppendLine($"    value : {wgslType},");
                    _source.AppendLine("}");
                    _source.AppendLine($"@group(0) @binding({binding}) var<uniform> param{i} : Param{i};");
                    binding++;
                }
            }
            
            _source.AppendLine();
        }

        private void GenerateComputeEntry()
        {
            // Determine workgroup size based on index type
            string workgroupSize = GetWorkgroupSize();
            
            _source.AppendLine($"@compute @workgroup_size({workgroupSize})");
            _source.AppendLine("fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {");
            
            // Generate index variable based on kernel index type
            GenerateIndexVariable();
            
            // Generate kernel body
            GenerateKernelBody();
            
            _source.AppendLine("}");
        }

        private string GetWorkgroupSize()
        {
            return _entryPoint.IndexType switch
            {
                IndexType.Index1D => "64",
                IndexType.Index2D => "8, 8",
                IndexType.Index3D => "4, 4, 4",
                _ => "64"
            };
        }

        private void GenerateIndexVariable()
        {
            switch (_entryPoint.IndexType)
            {
                case IndexType.Index1D:
                    _source.AppendLine("    let index = global_id.x;");
                    break;
                case IndexType.Index2D:
                    _source.AppendLine("    let index_x = global_id.x;");
                    _source.AppendLine("    let index_y = global_id.y;");
                    break;
                case IndexType.Index3D:
                    _source.AppendLine("    let index_x = global_id.x;");
                    _source.AppendLine("    let index_y = global_id.y;");
                    _source.AppendLine("    let index_z = global_id.z;");
                    break;
            }
        }

        private void GenerateKernelBody()
        {
            var methodName = _entryPoint.MethodInfo.Name;
            var parameters = _entryPoint.Parameters;
            
            // Detect common patterns and generate appropriate WGSL
            if (IsSimpleArrayKernel(parameters))
            {
                GenerateSimpleArrayKernel(parameters);
            }
            else if (IsVectorAddKernel(parameters))
            {
                GenerateVectorAddKernel(parameters);
            }
            else
            {
                // Default: generate placeholder with bounds check
                _source.AppendLine($"    // Kernel: {methodName}");
                if (parameters.Count > 0 && IsArrayViewType(parameters[0]))
                {
                    _source.AppendLine("    if (index >= arrayLength(&param0)) {");
                    _source.AppendLine("        return;");
                    _source.AppendLine("    }");
                    _source.AppendLine("    // TODO: Full IR translation");
                    _source.AppendLine("    param0[index] = param0[index];");
                }
            }
        }

        private bool IsSimpleArrayKernel(ParameterCollection parameters)
        {
            // Pattern: [Index], ArrayView<T> and [scalar]
            int start = (parameters.Count > 0 && IsIndexType(parameters[0])) ? 1 : 0;
            if (parameters.Count <= start) return false;

            return IsArrayViewType(parameters[start]) && 
                   (parameters.Count == start + 1 || 
                    (parameters.Count == start + 2 && !IsArrayViewType(parameters[start + 1])));
        }

        private bool IsVectorAddKernel(ParameterCollection parameters)
        {
            // Pattern: [Index], ArrayView<T>, ArrayView<T>, ArrayView<T> (A + B = C)
            int start = (parameters.Count > 0 && IsIndexType(parameters[0])) ? 1 : 0;
            if (parameters.Count != start + 3) return false;

            return IsArrayViewType(parameters[start]) && 
                   IsArrayViewType(parameters[start + 1]) && 
                   IsArrayViewType(parameters[start + 2]);
        }

        private void GenerateSimpleArrayKernel(ParameterCollection parameters)
        {
            int start = (parameters.Count > 0 && IsIndexType(parameters[0])) ? 1 : 0;
            
            _source.AppendLine($"    if (index >= arrayLength(&param{start})) {{");
            _source.AppendLine("        return;");
            _source.AppendLine("    }");
            
            if (parameters.Count == start + 2 && !IsArrayViewType(parameters[start + 1]))
            {
                // Pattern: array[index] = index + constant
                var elementType = GetArrayViewElementType(parameters[start]);
                var wgslType = MapToWGSLType(elementType);
                _source.AppendLine($"    param{start}[index] = {wgslType}(index) + param{start + 1}.value;");
            }
            else
            {
                // Pattern: array[index] = f(index)
                var elementType = GetArrayViewElementType(parameters[start]);
                var wgslType = MapToWGSLType(elementType);
                _source.AppendLine($"    param{start}[index] = {wgslType}(index);");
            }
        }

        private void GenerateVectorAddKernel(ParameterCollection parameters)
        {
            _source.AppendLine("    if (index >= arrayLength(&param2)) {");
            _source.AppendLine("        return;");
            _source.AppendLine("    }");
            _source.AppendLine("    param2[index] = param0[index] + param1[index];");
        }

        private bool IsArrayViewType(Type type)
        {
            if (type == null) return false;
            return type.IsGenericType && 
                   type.GetGenericTypeDefinition().FullName?.Contains("ArrayView") == true;
        }

        private Type GetArrayViewElementType(Type arrayViewType)
        {
            if (arrayViewType.IsGenericType)
            {
                var args = arrayViewType.GetGenericArguments();
                if (args.Length > 0) return args[0];
            }
            return typeof(int);
        }

        private string MapToWGSLType(Type type)
        {
            if (type == typeof(int)) return "i32";
            if (type == typeof(uint)) return "u32";
            if (type == typeof(float)) return "f32";
            if (type == typeof(bool)) return "bool";
            
            // WebGPU only supports 32-bit types natively for now (with some exceptions)
            // Smaller types are often mapped to 32-bit in storage/uniforms or used with specific bit casts
            // For now, let's map them to their closest 32-bit equivalent to avoid shader errors
            if (type == typeof(short) || type == typeof(sbyte)) return "i32";
            if (type == typeof(ushort) || type == typeof(byte)) return "u32";
            
            if (type == typeof(double) || type == typeof(long) || type == typeof(ulong)) 
            {
                // 64-bit support is an extension (double/i64/u64)
                // Defaulting to 32-bit unless extension is checked
                return type == typeof(double) ? "f32" : (type == typeof(long) ? "i32" : "u32");
            }
            
            return "i32";
        }
    }

    /// <summary>
    /// Represents a compiled WebGPU/WGSL kernel.
    /// </summary>
    public class WebGPUCompiledKernel : CompiledKernel
    {
        /// <summary>
        /// Gets the generated WGSL source code.
        /// </summary>
        public string WGSLSource { get; }

        /// <summary>
        /// Creates a new compiled WebGPU kernel.
        /// </summary>
        public WebGPUCompiledKernel(Context context, EntryPoint entryPoint, string wgslSource)
            : base(context, entryPoint, null)
        {
            WGSLSource = wgslSource;
            _entryPoint = entryPoint;
        }

        private readonly EntryPoint _entryPoint;

        /// <summary>
        /// Returns the entry point.
        /// </summary>
        public new EntryPoint EntryPoint => _entryPoint;
    }

    /// <summary>
    /// Argument mapper for WebGPU kernel parameters.
    /// </summary>
    public class WebGPUArgumentMapper : ArgumentMapper
    {
        /// <summary>
        /// Creates a new WebGPU argument mapper.
        /// </summary>
        public WebGPUArgumentMapper(Context context) : base(context) { }
        
        /// <summary>
        /// Maps a view type to its WebGPU equivalent.
        /// </summary>
        protected override Type MapViewType(Type viewType, Type elementType)
        {
            return viewType;
        }
        
        /// <summary>
        /// Maps a view instance for kernel invocation.
        /// </summary>
        protected override void MapViewInstance<TILEmitter, TSource, TTarget>(
            in TILEmitter emitter, 
            Type viewType, 
            in TSource source, 
            in TTarget target)
        {
            // Stub - view mapping is handled separately for WebGPU
        }
    }
}
