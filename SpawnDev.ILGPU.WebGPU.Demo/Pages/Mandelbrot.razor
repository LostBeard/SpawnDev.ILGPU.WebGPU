@page "/mandelbrot"
@implements IAsyncDisposable
@using SpawnDev.ILGPU.WebGPU
@using SpawnDev.ILGPU.WebGPU.Backend
@using SpawnDev.BlazorJS
@using SpawnDev.BlazorJS.JSObjects
@using ILGPU
@using System.Diagnostics
@using System.Runtime.InteropServices
@using global::ILGPU
@using global::ILGPU.Runtime

<PageTitle>Mandelbrot Explorer</PageTitle>

<h1>Mandelbrot Explorer</h1>

<div class="row mb-3">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span>Performance Comparison</span>
                <div class="form-check form-switch mb-0">
                    <input class="form-check-input" type="checkbox" id="mode64bit" @bind="_use64BitMode" />
                    <label class="form-check-label" for="mode64bit">64-bit Precision (ILGPU Only)</label>
                </div>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <label class="form-label">ILGPU Time</label>
                        <div class="form-control-plaintext"><strong class="text-primary">@_ilgpuRenderTime</strong></div>
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Raw WebGPU Time</label>
                        <div class="form-control-plaintext"><strong class="text-success">@_webgpuRenderTime</strong></div>
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Max Iterations</label>
                        <input type="number" class="form-control" @bind="_maxIterations" min="50" max="5000" step="50" />
                    </div>
                </div>
                <div class="row mt-2">
                    <div class="col-md-12">
                        <small class="text-muted">
                            <strong>Zoom:</strong> @_zoom.ToString("F6") | 
                            <strong>Center:</strong> (@_centerX.ToString("F6"), @_centerY.ToString("F6"))
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">Instructions</div>
            <div class="card-body">
                <ul class="mb-0">
                    <li><strong>Zoom:</strong> Mouse wheel</li>
                    <li><strong>Pan:</strong> Click and drag</li>
                    <li><strong>Reset:</strong> Double-click</li>
                </ul>
                <hr />
                <small class="text-muted">
                    @if (_use64BitMode)
                    {
                        <span><strong>64-bit Mode:</strong> Uses emulated f64 precision for deeper zooms (ILGPU only).</span>
                    }
                    else
                    {
                        <span>Alternates between ILGPU and Raw WebGPU each frame for comparison.</span>
                    }
                </small>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-12 text-center">
        <canvas @ref="mandelbrotCanvas" 
                width="@_width" 
                height="@_height" 
                style="border: 1px solid #ccc; cursor: crosshair;"
                tabindex="0"
                @onwheel="OnWheel"
                @onwheel:preventDefault
                @onmousedown="OnMouseDown"
                @onmousemove="OnMouseMove"
                @onmouseup="OnMouseUp"
                @onmouseleave="OnMouseUp"
                @ondblclick="OnDoubleClick"></canvas>
    </div>
</div>

@code {
    [Inject]
    BlazorJSRuntime JS { get; set; } = default!;

    ElementReference mandelbrotCanvas;

    // Canvas size
    private int _width = 800;
    private int _height = 600;

    // Mandelbrot parameters
    private double _centerX = -0.5;
    private double _centerY = 0.0;
    private double _zoom = 1.0;
    private int _maxIterations = 500;

    // Alternating renderer state
    private bool _useILGPU = true;
    private int _frameCount = 0;

    // 64-bit mode toggle
    private bool _use64BitMode = false;
    private bool _currentKernelUsesF64 = false; // Track what mode the kernel was compiled with

    // Status
    private bool _isRunning = false;
    private bool _disposed = false;
    private string _ilgpuRenderTime = "-";
    private string _webgpuRenderTime = "-";

    // UI update throttling
    private DateTime _lastUiUpdate = DateTime.MinValue;
    private const int UI_UPDATE_INTERVAL_MS = 100; // 10 updates per second max

    // Mouse drag tracking
    private bool _isDragging = false;
    private double _lastMouseX;
    private double _lastMouseY;

    // Cached ILGPU resources
    private Context? _ilgpuContext;
    private Accelerator? _ilgpuAccelerator;
    private Action<Index2D, ArrayView2D<uint, Stride2D.DenseX>, int, int, int, double, double, double>? _ilgpuKernel;
    private MemoryBuffer2D<uint, Stride2D.DenseX>? _ilgpuBuffer;

    // Cached Raw WebGPU resources
    private GPUDevice? _webgpuDevice;
    private GPUComputePipeline? _webgpuPipeline;
    private GPUBuffer? _webgpuOutputBuffer;
    private GPUBuffer? _webgpuUniformBuffer;
    private GPUBuffer? _webgpuReadBuffer;
    private GPUBindGroup? _webgpuBindGroup;
    private GPUBindGroupLayout? _webgpuBindGroupLayout;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Start continuous render loop
            _ = RenderLoop();
        }
    }

    private async Task RenderLoop()
    {
        try
        {
            // Initialize both renderers
            await InitializeILGPU();
            await InitializeRawWebGPU();

            // Continuous render loop
            while (!_disposed)
            {
                if (_isRunning)
                {
                    await Task.Delay(10);
                    continue;
                }

                _frameCount++;

                if (_use64BitMode)
                {
                    // 64-bit mode: ILGPU only with f64 emulation
                    if (!_currentKernelUsesF64)
                    {
                        // Need to reload kernel with f64 emulation enabled
                        WebGPUBackend.EnableF64Emulation = true;
                        await ReloadKernel();
                        _currentKernelUsesF64 = true;
                    }
                    await RenderWithILGPU();
                }
                else
                {
                    // Comparison mode: alternate between renderers each frame
                    if (_currentKernelUsesF64)
                    {
                        // Need to reload kernel with f64 emulation disabled
                        WebGPUBackend.EnableF64Emulation = false;
                        await ReloadKernel();
                        _currentKernelUsesF64 = false;
                    }
                    if (_useILGPU)
                    {
                        await RenderWithILGPU();
                    }
                    else
                    {
                        await RenderWithWebGPU();
                    }
                    _useILGPU = !_useILGPU;
                }

                // Throttled UI update
                ThrottledStateHasChanged();

                // Small delay to allow UI updates
                await Task.Delay(1);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
        }
    }

    private void ThrottledStateHasChanged()
    {
        var now = DateTime.UtcNow;
        if ((now - _lastUiUpdate).TotalMilliseconds >= UI_UPDATE_INTERVAL_MS)
        {
            _lastUiUpdate = now;
            StateHasChanged();
        }
    }

    private void OnWheel(WheelEventArgs e)
    {
        double mouseX = e.OffsetX;
        double mouseY = e.OffsetY;

        double scale = 4.0 / _zoom;
        double mouseRealBefore = _centerX + (mouseX - _width / 2.0) * scale / _width;
        double mouseImagBefore = _centerY + (mouseY - _height / 2.0) * scale / _height;

        double zoomFactor = e.DeltaY < 0 ? 1.2 : 1.0 / 1.2;
        _zoom *= zoomFactor;
        _zoom = Math.Max(0.5, Math.Min(_zoom, 1e12));

        double newScale = 4.0 / _zoom;
        _centerX = mouseRealBefore - (mouseX - _width / 2.0) * newScale / _width;
        _centerY = mouseImagBefore - (mouseY - _height / 2.0) * newScale / _height;
    }

    private void OnMouseDown(MouseEventArgs e)
    {
        _isDragging = true;
        _lastMouseX = e.OffsetX;
        _lastMouseY = e.OffsetY;
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if (!_isDragging) return;

        double dx = e.OffsetX - _lastMouseX;
        double dy = e.OffsetY - _lastMouseY;

        double scale = 4.0 / _zoom;
        _centerX -= dx * scale / _width;
        _centerY -= dy * scale / _height;

        _lastMouseX = e.OffsetX;
        _lastMouseY = e.OffsetY;
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        _isDragging = false;
    }

    private void OnDoubleClick(MouseEventArgs e)
    {
        _centerX = -0.5;
        _centerY = 0.0;
        _zoom = 1.0;
    }

    private async Task InitializeILGPU()
    {
        if (_ilgpuContext != null) return;

        var webGpuDevice = await WebGPUDevice.GetDefaultDeviceAsync();
        if (webGpuDevice == null) throw new Exception("No WebGPU device found");

        _ilgpuContext = Context.Create(builder => builder.Default());
        var ilgpuDevice = new WebGPUILGPUDevice(webGpuDevice, 0);
        _ilgpuAccelerator = await ilgpuDevice.CreateAcceleratorAsync(_ilgpuContext);
        _ilgpuKernel = _ilgpuAccelerator.LoadAutoGroupedStreamKernel<Index2D, ArrayView2D<uint, Stride2D.DenseX>, int, int, int, double, double, double>(MandelbrotKernel);
        _ilgpuBuffer = _ilgpuAccelerator.Allocate2DDenseX<uint>(new Index2D(_width, _height));
    }

    private async Task ReloadKernel()
    {
        // CRITICAL: ILGPU caches compiled kernels by method signature. 
        // The emulation flags (EnableF64Emulation) are NOT part of the cache key.
        // So we MUST dispose the old accelerator and create a new one to get a fresh cache.
        
        Console.WriteLine($"[Mandelbrot] Reloading kernel with EnableF64Emulation={WebGPUBackend.EnableF64Emulation}");
        
        // Enable verbose logging to see the generated WGSL
        var originalVerbose = WebGPUBackend.VerboseLogging;
        WebGPUBackend.VerboseLogging = true;
        
        try
        {
            // Dispose old resources
            if (_ilgpuAccelerator != null)
            {
                await _ilgpuAccelerator.SynchronizeAsync();
            }
            
            _ilgpuKernel = null;
            _ilgpuBuffer?.Dispose();
            _ilgpuBuffer = null;
            _ilgpuAccelerator?.Dispose();
            _ilgpuAccelerator = null;
            _ilgpuContext?.Dispose();
            _ilgpuContext = null;
            
            // Recreate everything with fresh kernel cache
            var webGpuDevice = await WebGPUDevice.GetDefaultDeviceAsync();
            if (webGpuDevice == null) throw new Exception("No WebGPU device found");
            
            _ilgpuContext = Context.Create(builder => builder.Default());
            var ilgpuDevice = new WebGPUILGPUDevice(webGpuDevice, 0);
            _ilgpuAccelerator = await ilgpuDevice.CreateAcceleratorAsync(_ilgpuContext);
            _ilgpuKernel = _ilgpuAccelerator.LoadAutoGroupedStreamKernel<Index2D, ArrayView2D<uint, Stride2D.DenseX>, int, int, int, double, double, double>(MandelbrotKernel);
            _ilgpuBuffer = _ilgpuAccelerator.Allocate2DDenseX<uint>(new Index2D(_width, _height));
            
            Console.WriteLine($"[Mandelbrot] Kernel reloaded with fresh accelerator, f64 emulation: {WebGPUBackend.EnableF64Emulation}");
        }
        finally
        {
            WebGPUBackend.VerboseLogging = originalVerbose;
        }
    }

    private async Task RenderWithILGPU()
    {
        _isRunning = true;

        try
        {
            var sw = Stopwatch.StartNew();

            _ilgpuKernel!(_ilgpuBuffer!.IntExtent, _ilgpuBuffer.View, _width, _height, _maxIterations, _centerX, _centerY, _zoom);
            
            await _ilgpuAccelerator!.SynchronizeAsync();

            var webGpuMemBuffer = (WebGPUMemoryBuffer)((IArrayView)_ilgpuBuffer).Buffer;
            var bytes = await webGpuMemBuffer.NativeBuffer.CopyToHostAsync();

            var result = new uint[_width * _height];
            Buffer.BlockCopy(bytes, 0, result, 0, bytes.Length);

            sw.Stop();
            _ilgpuRenderTime = $"{sw.ElapsedMilliseconds} ms";

            await DrawToCanvas(result);
        }
        finally
        {
            _isRunning = false;
        }
    }

    static void MandelbrotKernel(Index2D index, ArrayView2D<uint, Stride2D.DenseX> output, int width, int height, int maxIterations, double centerX, double centerY, double zoom)
    {
        int x = index.X;
        int y = index.Y;

        if (x >= width || y >= height)
            return;

        double scale = 4.0 / zoom;
        double real = centerX + (x - width / 2.0) * scale / width;
        double imag = centerY + (y - height / 2.0) * scale / height;

        double cReal = real;
        double cImag = imag;
        double zReal = 0;
        double zImag = 0;

        int iterations = 0;
        while (iterations < maxIterations && (zReal * zReal + zImag * zImag) < 4.0)
        {
            double temp = zReal * zReal - zImag * zImag + cReal;
            zImag = 2.0 * zReal * zImag + cImag;
            zReal = temp;
            iterations++;
        }

        uint color;
        if (iterations == maxIterations)
        {
            color = 0xFF000000;
        }
        else
        {
            uint r = (uint)(iterations * 10) % 255;
            uint g = (uint)(iterations * 5) % 255;
            uint b = (uint)(iterations * 20) % 255;
            color = (0xFFu << 24) | (b << 16) | (g << 8) | r;
        }

        output[index] = color;
    }

    private async Task DrawToCanvas(uint[] pixels)
    {
        using var canvas = new HTMLCanvasElement(mandelbrotCanvas);
        using var context = canvas.GetContext<CanvasRenderingContext2D>("2d");
        using var uint32Array = new Uint32Array(pixels);
        using var uint8ClampedArray = new Uint8ClampedArray(uint32Array.Buffer);
        using var imageDataFromBuffer = new ImageData(uint8ClampedArray, (ulong)_width, (ulong)_height);
        context!.PutImageData(imageDataFromBuffer, 0, 0);
    }

    private async Task InitializeRawWebGPU()
    {
        if (_webgpuDevice != null) return;

        if (!WebGPUDevice.IsSupported) throw new Exception("WebGPU not supported");

        var navigator = JS.Get<Navigator>("navigator");
        using var gpu = navigator.Gpu;
        using var adapter = await gpu!.RequestAdapter();
        _webgpuDevice = await adapter.RequestDevice();

        var wgsl = @"
struct Params {
    width: u32,
    height: u32,
    maxIterations: u32,
    _pad: u32,
    centerX: f32,
    centerY: f32,
    zoom: f32,
};

@group(0) @binding(0) var<storage, read_write> output : array<u32>;
@group(0) @binding(1) var<uniform> params : Params;

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
    let x = global_id.x;
    let y = global_id.y;
    
    if (x >= params.width || y >= params.height) {
        return;
    }
    
    let width_f = f32(params.width);
    let height_f = f32(params.height);
    let scale = 4.0 / params.zoom;
    
    let real = params.centerX + (f32(x) - width_f / 2.0) * scale / width_f;
    let imag = params.centerY + (f32(y) - height_f / 2.0) * scale / height_f;
    
    var zReal = 0.0;
    var zImag = 0.0;
    let cReal = real;
    let cImag = imag;
    
    var iterations = 0u;
    while (iterations < params.maxIterations && (zReal * zReal + zImag * zImag) < 4.0) {
        let temp = zReal * zReal - zImag * zImag + cReal;
        zImag = 2.0 * zReal * zImag + cImag;
        zReal = temp;
        iterations = iterations + 1u;
    }
    
    var color = 0u;
    if (iterations == params.maxIterations) {
        color = 0xFF000000u;
    } else {
        let r = (iterations * 10u) % 255u;
        let g = (iterations * 5u) % 255u;
        let b = (iterations * 20u) % 255u;
        color = (0xFFu << 24) | (b << 16) | (g << 8) | r;
    }
    
    let index = y * params.width + x;
    output[index] = color;
}
";
        using var shaderModule = _webgpuDevice.CreateShaderModule(new GPUShaderModuleDescriptor
        {
            Code = wgsl,
            Label = "Mandelbrot Shader"
        });

        _webgpuPipeline = await _webgpuDevice.CreateComputePipelineAsync(new GPUComputePipelineDescriptor
        {
            Compute = new GPUProgrammableStage
            {
                Module = shaderModule,
                EntryPoint = "main"
            },
            Layout = "auto"
        });

        ulong bufferSize = (ulong)(_width * _height * 4);
        _webgpuOutputBuffer = _webgpuDevice.CreateBuffer(new GPUBufferDescriptor
        {
            Size = bufferSize,
            Usage = GPUBufferUsage.Storage | GPUBufferUsage.CopySrc,
            Label = "Output Buffer"
        });

        _webgpuUniformBuffer = _webgpuDevice.CreateBuffer(new GPUBufferDescriptor
        {
            Size = 32,
            Usage = GPUBufferUsage.Uniform | GPUBufferUsage.CopyDst,
            Label = "Params Buffer"
        });

        _webgpuReadBuffer = _webgpuDevice.CreateBuffer(new GPUBufferDescriptor
        {
            Size = bufferSize,
            Usage = GPUBufferUsage.MapRead | GPUBufferUsage.CopyDst,
            Label = "ReadBuffer"
        });

        _webgpuBindGroupLayout = _webgpuPipeline.GetBindGroupLayout(0);
        _webgpuBindGroup = _webgpuDevice.CreateBindGroup(new GPUBindGroupDescriptor
        {
            Layout = _webgpuBindGroupLayout,
            Entries = new GPUBindGroupEntry[]
            {
                new GPUBindGroupEntry { Binding = 0, Resource = new GPUBufferBinding { Buffer = _webgpuOutputBuffer } },
                new GPUBindGroupEntry { Binding = 1, Resource = new GPUBufferBinding { Buffer = _webgpuUniformBuffer } }
            }
        });
    }

    private async Task RenderWithWebGPU()
    {
        _isRunning = true;

        try
        {
            var sw = Stopwatch.StartNew();

            // Update uniforms
            var paramsBytes = new byte[32];
            BitConverter.GetBytes((uint)_width).CopyTo(paramsBytes, 0);
            BitConverter.GetBytes((uint)_height).CopyTo(paramsBytes, 4);
            BitConverter.GetBytes((uint)_maxIterations).CopyTo(paramsBytes, 8);
            BitConverter.GetBytes((uint)0).CopyTo(paramsBytes, 12);
            BitConverter.GetBytes((float)_centerX).CopyTo(paramsBytes, 16);
            BitConverter.GetBytes((float)_centerY).CopyTo(paramsBytes, 20);
            BitConverter.GetBytes((float)_zoom).CopyTo(paramsBytes, 24);

            _webgpuDevice!.Queue.WriteBuffer(_webgpuUniformBuffer!, 0, paramsBytes);

            using var commandEncoder = _webgpuDevice.CreateCommandEncoder();
            using var passEncoder = commandEncoder.BeginComputePass();
            passEncoder.SetPipeline(_webgpuPipeline!);
            passEncoder.SetBindGroup(0, _webgpuBindGroup!);
            passEncoder.DispatchWorkgroups((uint)Math.Ceiling(_width / 16.0), (uint)Math.Ceiling(_height / 16.0));
            passEncoder.End();

            ulong bufferSize = (ulong)(_width * _height * 4);
            commandEncoder.CopyBufferToBuffer(_webgpuOutputBuffer!, 0, _webgpuReadBuffer!, 0, bufferSize);

            using var commands = commandEncoder.Finish();
            _webgpuDevice.Queue.Submit(new[] { commands });

            await _webgpuReadBuffer!.MapAsync(GPUMapMode.Read);

            uint[] pixels = new uint[_width * _height];
            using (var mappedRange = _webgpuReadBuffer.GetMappedRange())
            {
                using var uintArray = new Uint32Array(mappedRange);
                var bytes = uintArray.ReadBytes();
                Buffer.BlockCopy(bytes, 0, pixels, 0, bytes.Length);
            }
            _webgpuReadBuffer.Unmap();

            sw.Stop();
            _webgpuRenderTime = $"{sw.ElapsedMilliseconds} ms";

            await DrawToCanvas(pixels);
        }
        finally
        {
            _isRunning = false;
        }
    }

    public async ValueTask DisposeAsync()
    {
        _disposed = true;

        // Dispose ILGPU resources
        _ilgpuBuffer?.Dispose();
        _ilgpuAccelerator?.Dispose();
        _ilgpuContext?.Dispose();

        // Dispose WebGPU resources
        _webgpuReadBuffer?.Dispose();
        _webgpuOutputBuffer?.Dispose();
        _webgpuUniformBuffer?.Dispose();
        _webgpuBindGroup?.Dispose();
        _webgpuPipeline?.Dispose();
        _webgpuDevice?.Dispose();
    }
}
